#!/usr/bin/python3

import argparse
import json
import os
from os import walk
from typing import Dict, List
from abc import ABC, abstractmethod

INDENT_PATTERN = "    "

class Dumpable(ABC):

    @abstractmethod
    def dump(self, indent_level=0):
        pass

    @staticmethod
    def dump_title(title: str, indent_level=1):
        indent = INDENT_PATTERN*indent_level
        print(f"{indent}{title}:")

    @staticmethod
    def dump_titled(title: str, item, indent_level=1):
        if isinstance(item, str):
            Dumpable.dump_titled_str(title, item, indent_level)
        elif isinstance(item, list):
            Dumpable.dump_titled_list(title, item, indent_level)
        elif isinstance(item, dict):
            Dumpable.dump_titled_dict(title, item, indent_level)
        elif isinstance(item, bool):
            Dumpable.dump_titled_bool(title, item, indent_level)
        elif isinstance(item, float):
            Dumpable.dump_titled_str(title, str(item), indent_level)
        elif isinstance(item, int):
            Dumpable.dump_titled_str(title, str(item), indent_level)
        else:
            print(f"unknown type {title}{item}")

    @staticmethod
    def dump_titled_bool(title: str, b: bool, indent_level=1):
        indent = INDENT_PATTERN*indent_level
        print(f"{indent}{title}={b}")

    @staticmethod
    def dump_str(s: str, indent_level=1):
        indent = INDENT_PATTERN*indent_level
        print(f"{indent}{s}")

    @staticmethod
    def dump_titled_str(title: str, s: str, indent_level=1):
        indent = INDENT_PATTERN*indent_level
        s = s.replace("\n", " ")
        print(f"{indent}{title}={s}")

    @staticmethod
    def dump_titled_list(title: str, lst: List, indent_level=1):
        Dumpable.dump_title(title, indent_level)
        Dumpable.dump_list(lst, indent_level+1)

    @staticmethod
    def dump_list(lst: List, indent_level=1):
        indent = INDENT_PATTERN*indent_level
        for item in lst:
            if isinstance(item, dict):
                Dumpable.dump_dict(item, indent_level)
            else:
                sitem = str(item).replace('\n', ' ')
                print(f"{indent}{sitem}")

    @staticmethod
    def dump_titled_dict(title: str, dct: Dict, indent_level=1):
        Dumpable.dump_title(title, indent_level)
        Dumpable.dump_dict(dct, indent_level+1)

    @staticmethod
    def dump_dict(dct: Dict, indent_level=1):
        for key, val in dct.items():
            Dumpable.dump_titled(key, val, indent_level)

# Single entry elements


class SingleEntry(Dumpable):

    def __init__(self, report: Dict, title: str, default_value):
        self.title = title
        self.content = report.get(title, default_value)

    def dump(self, indent_level=0):
        Bootloader.dump_titled(self.title, self.content, indent_level)


class Bootloader(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "bootloader", "")


class GroupsSystem(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "groups-system", [])


class PasswdSystem(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "passwd-system", [])


class BootEnv(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "boot-environment", {})


class DefaultTarget(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "default-target", "")


class Groups(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "groups", [])


class Hostname(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "hostname", "")


class MachineId(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "machine-id", "")


class OSRelease(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "os-release", {})


class Passwd(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "passwd", [])


class Timezone(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "timezone", "")


class ResolvConf(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "/etc/resolv.conf", [])

class ConfFolder(SingleEntry):

    def dump(self, indent_level=0):
        Dumpable.dump_title(self.title, indent_level)
        for filename, filecontent in self.content.items():
            Dumpable.dump_titled(f"file {filename}", filecontent, indent_level+1)

class Sudoers(ConfFolder):

    def __init__(self, report: Dict):
        super().__init__(report, "sudoers", {})


class Locale(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "locale", {})

class DnfAutomaticConf(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "/etc/dnf/automatic.conf", {})

class SystemDLoginD(ConfFolder):

    def __init__(self, report: Dict):
        super().__init__(report, "systemd-logind", {})


class Hosts(SingleEntry):

    def __init__(self, report):
        super().__init__(report, "hosts", [])



class RpmNotInstalled(SingleEntry):

    def __init__(self, report):
        super().__init__(report, "rpm_not_installed_docs", [])

# Multiple entries elements

class ConstructedMultipleEntries(Dumpable):

    def __init__(self, title: str):
        self.title = title
        self.has_content = True
        self.report_content = {}

    def dump(self, indent_level=1):
        Dumpable.dump_title(self.title)
        self.dump_all(indent_level)

    @abstractmethod
    def dump_all(self, indent_level):
        pass

class MultipleEntries(ConstructedMultipleEntries):

    def __init__(self, report:Dict, title: str):
        super().__init__(title)
        self.report_content = report.get(title)
        self.has_content = title in report


    def get_list(self, name):
        if self.has_content:
            return self.report_content.get(name, [])
        return []

    def get_dict(self, name):
        if self.has_content:
            return self.report_content.get(name, {})
        return {}

    def get_str(self, name):
        if self.has_content:
            return self.report_content.get(name, "")
        return ""



class AuthselectConf(MultipleEntries):

    def __init__(self, report: Dict):
        super().__init__(report, "authselect")
        self.profile_id = self.get_str("profile-id")
        self.enabled_features = self.get_dict("enabled-features")

    def dump_all(self, indent_level):
        Dumpable.dump_titled("profile-id", self.profile_id, indent_level)
        Dumpable.dump_titled("enabled-features", self.enabled_features, indent_level)


class Chrony(MultipleEntries):

    def __init__(self, report: Dict):
        super().__init__(report, "chrony")
        self.leapsectz = self.get_dict("leapsectz")
        self.peer = self.get_dict("peer")
        self.pool = self.get_dict("pool")
        self.server = self.get_dict("server")

    def dump_all(self, indent_level):
        Dumpable.dump_titled("leapsectz", self.leapsectz, indent_level)
        Dumpable.dump_titled("peer", self.peer, indent_level)
        Dumpable.dump_titled("pool", self.pool, indent_level)
        Dumpable.dump_titled("server", self.server, indent_level)


class Dnf(MultipleEntries):

    def __init__(self, report: Dict):
        super().__init__(report, "DNF")
        self.dnf_conf = self.get_dict("dnf.conf")
        self.vars = self.get_dict("vars")

    def dump_all(self, indent_level):
        Dumpable.dump_titled("dnf.conf", self.dnf_conf, indent_level)
        Dumpable.dump_titled("vars", self.vars, indent_level)


class Keyboard(MultipleEntries):

    def __init__(self, report):
        super().__init__(report, "keyboard")
        self.x11 = self.get_dict("x11")
        self.vconsole = self.get_dict("vconsole")

    def dump_all(self, indent_level):
        Dumpable.dump_titled("x11", self.x11, indent_level)
        Dumpable.dump_titled("vconsole", self.vconsole, indent_level)



class TunedProfile(MultipleEntries):

    def __init__(self, report: Dict):
        super().__init__(report, "tuned")
        self.active_profile = self.get_str("active_profile")
        self.profile_mode = self.get_str("profile_mode")

    def dump_all(self, indent_level):
        Dumpable.dump_titled("active_profile", self.active_profile, indent_level)
        Dumpable.dump_titled("profile_mode", self.profile_mode, indent_level)


class RpmVerify(MultipleEntries):

    def __init__(self, report: Dict):
        super().__init__(report, "rpm-verify")
        self.changed = self.get_dict("changed")
        self.missing = self.get_list("missing")

    def dump_all(self, indent_level):
        Dumpable.dump_titled("changed", self.changed, indent_level)
        Dumpable.dump_titled("missing", self.missing, indent_level)

class Services(ConstructedMultipleEntries):

    def __init__(self, report: Dict):
        super().__init__("services")
        self.enabled = report["services-enabled"]
        self.disabled = report["services-disabled"]

    def dump_all(self, indent_level):
        Dumpable.dump_titled("services-enabled", self.enabled, indent_level)
        Dumpable.dump_titled("services-disabled", self.disabled, indent_level)


class Firewall(ConstructedMultipleEntries):

    def __init__(self, report):
        super().__init__("firewall")
        self.enabled = report.get("firewall-enabled", [])
        self.zone = report.get("firewall-default-zone", "")

    def dump_all(self, indent_level):
        Dumpable.dump_titled("firewall-enabled", self.enabled, indent_level)
        Dumpable.dump_titled("firewall-default-zone", self.zone, indent_level)

class ImageFormat(ConstructedMultipleEntries):

    def __init__(self, report: Dict):
        super().__init__("image-format")
        self.image_format = report["image-format"]["type"]
        self.compat = ""
        if self.image_format == "qcow2":
            self.compat = report["image-format"].get("compat")

    def dump_all(self, indent_level):
        Dumpable.dump_titled("image-format/type", self.image_format, indent_level)
        Dumpable.dump_titled("image-format/compat", self.compat, indent_level)

class OStree:

    def __init__(self, report: Dict):
        super().__init__("ostree")
        self.repo = report["ostree"]["repo"]
        self.refs = report["ostree"]["refs"]

    def dump_all(self, indent_level):
        Dumpable.dump_titled("ostree/repo", self.repo, indent_level)
        Dumpable.dump_titled("ostree/refs", self.refs, indent_level)

# configuration folder elements

class UdevRules(Dumpable):

    def __init__(self, report: Dict):
        self.rules = {}
        if "/etc/udev/rules.d" in report:
            for file, rules in report["/etc/udev/rules.d"].items():
                self.rules[file] = rules

    def dump(self, indent_level=0):
        Dumpable.dump_titled("/etc/udev/rules.d",self.rules, indent_level)

class MultiLevelConfFolder(Dumpable):

    def __init__(self, report: Dict, keyname: str):
        self.title = keyname
        self.folder_content = {}
        for folder, content in report.get(keyname, {}).items():
            for file, config in content.items():
                if folder not in self.folder_content:
                    self.folder_content[folder] = {}
                self.folder_content[folder][file] = config

    def dump(self, indent_level=0):
        Dumpable.dump_title(self.title, indent_level)
        for folder, foldercontent in self.folder_content.items():
            Dumpable.dump_title(f"folder {folder}", indent_level+1)
            for file, content in foldercontent.items():
                Dumpable.dump_titled_list(f"file {file}",
                                  content,
                                  indent_level+2)


class CloudIinit(MultiLevelConfFolder):

    def __init__(self, report: Dict):
        super().__init__(report, "cloud-init")


class Dracut(MultiLevelConfFolder):

    def __init__(self, report: Dict):
        super().__init__(report, "dracut")


class SecurityLimits(MultiLevelConfFolder):

    def __init__(self, report: Dict):
        super().__init__(report, "security-limits")


class TmpFiles(MultiLevelConfFolder):

    def __init__(self, report: Dict):
        super().__init__(report, "tmpfiles")


class SSHConfig(MultiLevelConfFolder):

    def __init__(self, report: Dict):
        super().__init__(report, "ssh_config")


class SSHDConfig(MultiLevelConfFolder):

    def __init__(self, report: Dict):
        super().__init__(report, "sshd_config")


class SysctlD(MultiLevelConfFolder):

    def __init__(self, report: Dict):
        super().__init__(report, "sysctl.d")


class SystemDServiceDropin(MultiLevelConfFolder):

    def __init__(self, report: Dict):
        super().__init__(report, "systemd-service-dropins")


# Composed elements

class SELinuxContext(Dumpable):

    def __init__(self, context: Dict):
        self.actual = context["actual"]
        self.expected = context["expected"]
        self.filename = context["filename"]

    def dump(self, indent_level=0):
        Dumpable.dump_titled("actual", self.actual, indent_level)
        Dumpable.dump_titled("expected", self.expected, indent_level)
        Dumpable.dump_titled("filename", self.filename, indent_level)


class SELinux(MultipleEntries):

    def __init__(self, report: Dict):
        super().__init__(report, "selinux")
        self.policy = self.get_dict("policy")
        self.context_mismatch = []
        if self.has_content:
            for context in self.get_list("context-mismatch"):
                self.context_mismatch.append(SELinuxContext(context))

    def dump_all(self, indent_level):
        Dumpable.dump_titled("policy", self.policy, indent_level)
        Dumpable.dump_title("context-mismatch", indent_level)
        for slnxc in self.context_mismatch:
            slnxc.dump(indent_level+1)

class BootEntry(Dumpable):

    def __init__(self, entry: Dict):
        self.entry = entry

    def dump(self, indent_level=0):
        Dumpable.dump_titled("boot-entry", self.entry, indent_level)

class BootMenu(Dumpable):

    def __init__(self, report: Dict):
        self.boot_entries = []
        if "bootmenu" in report:
            for entry in report["bootmenu"]:
                self.boot_entries.append(BootEntry(entry))

    def dump(self, indent_level=0):
        Dumpable.dump_title("bootmenu", indent_level)
        for entry in self.boot_entries:
            entry.dump(indent_level+1)


class NetworkScript(Dumpable):

    def __init__(self, name, configuration):
        self.name = name
        self.configuration = configuration

    def dump(self, indent_level=0):
        Dumpable.dump_titled("name", self.name, indent_level)
        Dumpable.dump_titled("configuration", self.configuration, indent_level)


class SysConfig(MultipleEntries):

    def __init__(self, report: Dict):
        super().__init__(report, "sysconfig")
        self.kernel = self.get_dict("kernel")
        self.network = self.get_dict("network")
        self.network_scripts = []
        if self.has_content:
            for iface, config in self.get_dict("network-scripts").items():
                self.network_scripts.append(NetworkScript(iface, config))

    def dump_all(self, indent_level):
        Dumpable.dump_titled("kernel", self.kernel, indent_level)
        Dumpable.dump_titled("network", self.network, indent_level)
        for ntscrpt in self.network_scripts:
            ntscrpt.dump(indent_level+1)

class RHSMConf(Dumpable):

    def __init__(self, rhsm: Dict):
        self.logging = rhsm.get("logging")
        self.rhsm = rhsm.get("rhsm")
        self.rhsmcertd = rhsm.get("rhsmcertd")
        self.server = rhsm.get("server")

    def dump(self, indent_level=0):
        Dumpable.dump_titled("logging", self.logging, indent_level)
        Dumpable.dump_titled("rhsm", self.rhsm, indent_level)
        Dumpable.dump_titled("rhsmcertd", self.rhsmcertd, indent_level)
        Dumpable.dump_titled("server", self.server, indent_level)

class DnfPluginsConfig(Dumpable):

    def __init__(self, product_id, subscription_manager):
        self.product_id = "true" in product_id
        self.subscription_manager = "true" in subscription_manager

    def dump(self, indent_level=0):
        Dumpable.dump_title("dnf-plugins", indent_level)
        Dumpable.dump_titled("product-id", self.product_id, indent_level+1)
        Dumpable.dump_titled("subscription-manager", self.subscription_manager,
                indent_level+1)



class RHSM(MultipleEntries):

    def __init__(self, report: Dict):
        super().__init__(report, "rhsm")
        self.rhsm_conf = self.get_dict("rhsm.conf")
        self.dnf_plugins = None
        if self.has_content:
            if "dnf-plugins" in self.report_content:
                self.dnf_plugins = DnfPluginsConfig(
                    self.report_content["dnf-plugins"]["product-id"],
                    self.report_content["dnf-plugins"]["subscription-manager"])

    def dump_all(self, indent_level):
        Dumpable.dump_titled("rhsm.conf", self.rhsm_conf, indent_level)
        if self.dnf_plugins:
            self.dnf_plugins.dump()

class BlacklistModule(Dumpable):

    def __init__(self, path: str, blacklist: List):
        self.path = path
        self.blacklist = blacklist

    def dump(self, indent_level=0):
        Dumpable.dump_titled("path", self.path, indent_level)
        Dumpable.dump_titled("blacklist", self.blacklist, indent_level+1)

class Modprobe(Dumpable):

    def __init__(self, report: Dict):
        self.folder_conf = {}
        if "modprobe" in report:
            for folder, content in report["modprobe"].items():
                for path, blacklist in content.items():
                    self.folder_conf[folder] = BlacklistModule(path, blacklist)

    def dump(self, indent_level=0):
        Dumpable.dump_title("Modprobe", indent_level)
        for folder, bl in self.folder_conf.items():
            Dumpable.dump_title(folder, indent_level+1)
            bl.dump(indent_level+2)


class Package(Dumpable):

    def __init__(self, package: str):
        self.package_name = package.split(".")[0]
        self.version = ".".join(package.split(".")[1:])

    def dump(self, indent_level=0):
        Dumpable.dump_str(f"{self.package_name} @version {self.version}", indent_level)

class Packages(Dumpable):

    def __init__(self, report: Dict):
        self.packages = []
        for package in report.get("packages", []):
            self.packages.append(Package(package))

    def dump(self, indent_level=0):
        Dumpable.dump_title("packages")
        for pkg in self.packages:
            pkg.dump(indent_level+1)


class Repo(Dumpable):

    def __init__(self, name, repo):
        self.name = name
        self.baseurl = repo.get("baseurl", "")
        self.enabled = repo.get("enabled", "")
        self.gpgkey = repo.get("gpgkey", "")
        self.name = repo.get("name", "")
        self.repo_gpgcheck = repo.get("repo_gpgcheck", "")

    def dump(self, indent_level=0):
        Dumpable.dump_title(self.name, indent_level)
        Dumpable.dump_titled("baseurl", self.baseurl, indent_level+1)
        Dumpable.dump_titled("enabled", self.enabled, indent_level+1)
        Dumpable.dump_titled("gpgkey", self.gpgkey, indent_level+1)
        Dumpable.dump_titled("name", self.name, indent_level+1)
        Dumpable.dump_titled("repo_gpgcheck", self.repo_gpgcheck, indent_level+1)


class YumRepos(Dumpable):

    def __init__(self, report: Dict):
        self.repos = {}
        if "yum_repos" in report:
            for file, repo in report["yum_repos"].items():
                if file not in self.repos:
                    self.repos[file] = {}
                for rep, repos_content in repo.items():
                    if rep not in self.repos[file]:
                        self.repos[file][rep] = []
                    for name, info in repos_content.items():
                        self.repos[file][rep].append(Repo(name, info))

    def dump(self, indent_level=0):
        Dumpable.dump_title("yum-repos", indent_level)
        for file, repos in self.repos.items():
            Dumpable.dump_title(file, indent_level+1)
            for r, lst in repos.items():
                Dumpable.dump_title(r, indent_level+2)
                for repo in lst:
                    repo.dump(indent_level+3)


class FStabEntry(Dumpable):

    def __init__(self, entry: List):
        self.info = entry

    def dump(self, indent_level=0):
        Dumpable.dump_titled("fstab-entry", self.info, indent_level)


class FStab(Dumpable):

    def __init__(self, report):
        self.entries = []
        if "fstab" in report:
            for entry in report["fstab"]:
                self.entries.append(FStabEntry(entry))

    def dump(self, indent_level=0):
        Dumpable.dump_title("fstab", indent_level)
        for entry in self.entries:
            entry.dump(indent_level+1)

class Partition(Dumpable):

    def __init__(self, report: Dict):
        self.bootable = report["bootable"]
        self.partuuid = report["partuuid"]
        self.size = report["size"]
        self.type = report["type"]

    def dump(self, indent_level=0):
        Dumpable.dump_titled("bootable", self.bootable, indent_level)
        Dumpable.dump_titled("partuuid", self.partuuid, indent_level)
        Dumpable.dump_titled("size", self.size, indent_level)
        Dumpable.dump_titled("type", self.type, indent_level)

class Partitions(Dumpable):

    def __init__(self, report: Dict):
        self.partition_table = ""
        self.partition_table_id = ""
        self.partitions = []
        if report.get("partition-table"):
            self.partition_table = report["partition-table"]
            self.partition_table_id = report["partition-table-id"]
            for item in report["partitions"]:
                self.partitions.append(Partition(item))

    def dump(self, indent_level=0):
        Dumpable.dump_titled("partition-table", self.partition_table, indent_level)
        Dumpable.dump_titled("partition-table-id", self.partition_table_id, indent_level)
        Dumpable.dump_title("partitions", indent_level)
        for partition in self.partitions:
            partition.dump(indent_level+1)

# entry point classes


class ImageInfo(Dumpable):

    def __init__(self, report, name):
        self.name = name
        self.report_content = {
            "authselect": AuthselectConf(report),
            "boot-environment": BootEnv(report),
            "bootmenu": BootMenu(report),
            "chrony": Chrony(report),
            "cloud-init": CloudIinit(report),
            "default-target": DefaultTarget(report),
            "dnf": Dnf(report),
            "dnf_automatic_conf": DnfAutomaticConf(report),
            "dracut": Dracut(report),
            "firewall": Firewall(report),
            "fstab": FStab(report),
            "groups": Groups(report),
            "hostname": Hostname(report),
            "hosts": Hosts(report),
            "keyboad": Keyboard(report),
            "locale": Locale(report),
            "machine-id": MachineId(report),
            "modprobe": Modprobe(report),
            "os-release": OSRelease(report),
            "packages": Packages(report),
            "passwd": Passwd(report),
            "resolv-conf": ResolvConf(report),
            "rhsm": RHSM(report),
            "rpm-not-installed-docs": RpmNotInstalled(report),
            "rpm-verify": RpmVerify(report),
            "security-limits": SecurityLimits(report),
            "selinux": SELinux(report),
            "services": Services(report),
            "ssh-configs": SSHConfig(report),
            "sshd-configs": SSHDConfig(report),
            "sudoers-conf": Sudoers(report),
            "sysconfig": SysConfig(report),
            "sysctld-configs": SysctlD(report),
            "systemd-logind": SystemDLoginD(report),
            "systemd-service-dropins": SystemDServiceDropin(report),
            "timezone": Timezone(report),
            "tmpfiles-d": TmpFiles(report),
            "tuned-profile": TunedProfile(report),
            "udev-rules": UdevRules(report),
            "yum-repos": YumRepos(report)
        }

    @classmethod
    def get_imi(cls, report: Dict, name):
        if report is None:
            return None
        if (report.get("type", None) == "ostree/commit" or
                report.get("type", None) == "ostree/repo"):
            # image-info represents a ostree repo
            return OSTreeInfoImage(report, name)
        if report.get("bootloader", None):
            # image-info represents an image
            return ImageInfoImage(report, name)
        # image-info represents a directory
        return DirectoryInfoImage(report, name)

    def dump(self, indent_level=0):
        print(f"Image Info content: {self.name}")
        for _, obj in self.report_content.items():
            obj.dump(indent_level+1)

class ImageInfoImage(ImageInfo):

    def __init__(self, report, name):
        super().__init__(report, name)
        self.report_content["partitions"] = Partitions(report)
        self.report_content["image-format"] = ImageFormat(report)
        self.report_content["bootloader"] = Bootloader(report)

class OSTreeInfoImage(ImageInfo):

    def __init__(self, report, name):
        super().__init__(report, name)
        self.report_content["ostree"]: OStree(report)
        self.report_content["groups-system"]: GroupsSystem(report)
        self.report_content["passwd-system"]: PasswdSystem(report)


class DirectoryInfoImage(ImageInfo):
    pass


def load_input(filename, filetype):
    with open(filename, encoding="utf-8") as f:
        if filetype == "only":
            return ImageInfoImage.get_imi(json.load(f), filename)
        return ImageInfoImage.get_imi(json.load(f)["image-info"], filename)


def main():
    parser = argparse.ArgumentParser(description="Inspect an image")
    parser.add_argument("--folder",
                        type=os.path.abspath,
                        help="a folder containing files with the image-info")
    parser.add_argument("--input",
                        type=os.path.abspath,
                        help="a file containing the image-info")
    parser.add_argument("--input-type",
                        type=str,
                        choices=["only", "test_case"],
                        default="test_case",
                        help="input contains image info only or embedded in a test case")

    args = parser.parse_args()
    filenames = [args.input]
    if args.folder:
        filenames = next(walk(args.folder), (None, None, []))[2]
        filenames = [f'{args.folder}/{f}' for f in filenames]
    for filename in filenames:
        imi = load_input(filename, args.input_type)
        if imi:
            imi.dump()


if __name__ == "__main__":
    main()
