#!/usr/bin/python3
#pylint: disable=[too-many-lines]

import argparse
import json
import os
from os import walk
import tempfile
from typing import Dict, List
from abc import ABC, abstractmethod
from contextlib import contextmanager

INDENT_PATTERN = "    "


def custom_path_join(*paths):
    abspath = paths[0].startswith("/")
    total_elements = []
    for path in paths:
        total_elements.extend(path.split("/"))
    while "" in total_elements:
        total_elements.remove("")
    joined = "/".join(total_elements)
    if abspath:
        return f"/{joined}"
    return joined


def get_folder(path: str):
    abspath = path.startswith("/")
    split = path.split("/")
    while "" in split:
        split.remove("")
    joined = "/".join(split[:-1])
    if abspath:
        return f"/{joined}"
    return joined


def create_parent(file):
    folder = get_folder(file)
    os.makedirs(folder, exist_ok=True)


class Extractable(ABC):

    @abstractmethod
    def extract(self, root):
        pass

    @staticmethod
    @contextmanager
    def openf(path, extract=False):
        if extract:
            path = f"{path}.imi"
        create_parent(path)
        with open(path, mode="w", encoding="utf-8") as f:
            yield f

    @staticmethod
    def open_and_write(path, item, extract=False):
        with Extractable.openf(path, extract) as f:
            Extractable.write_all(f, item)

    @staticmethod
    def write_all(f, item, indent_level=0):
        if isinstance(item, list):
            Extractable.write_list(f, item, indent_level)
        elif isinstance(item, dict):
            Extractable.write_dict(f, item, indent_level)
        else:
            Extractable.write_str(f, str(item), indent_level)

    @staticmethod
    def write_str(f, s: str, indent_level=0):
        indent = INDENT_PATTERN*indent_level
        f.write(f"{indent}{s}\n")

    @staticmethod
    def write_list(f, l: List, indent_level=0):
        for item in l:
            Extractable.write_all(f, item, indent_level)

    @staticmethod
    def write_dict(f, d: Dict, indent_level=0):
        for k, v in d.items():
            Extractable.write_titled(f, f"[{k}]", v, indent_level)

    @staticmethod
    def write_titled(f, key, value, indent_level=0):
        Extractable.write_all(f, key)
        Extractable.write_all(f, value, indent_level+1)


class Dumpable(ABC):

    @abstractmethod
    def dump(self, indent_level=0):
        pass

    @staticmethod
    def dump_title(title: str, indent_level=1):
        indent = INDENT_PATTERN*indent_level
        print(f"{indent}{title}:")

    @staticmethod
    def dump_titled(title: str, item, indent_level=1):
        if isinstance(item, str):
            Dumpable.dump_titled_str(title, item, indent_level)
        elif isinstance(item, list):
            Dumpable.dump_titled_list(title, item, indent_level)
        elif isinstance(item, dict):
            Dumpable.dump_titled_dict(title, item, indent_level)
        elif isinstance(item, bool):
            Dumpable.dump_titled_bool(title, item, indent_level)
        elif isinstance(item, float):
            Dumpable.dump_titled_str(title, str(item), indent_level)
        elif isinstance(item, int):
            Dumpable.dump_titled_str(title, str(item), indent_level)
        else:
            print(f"unknown type {title}{item}")

    @staticmethod
    def dump_titled_bool(title: str, b: bool, indent_level=1):
        indent = INDENT_PATTERN*indent_level
        print(f"{indent}{title}={b}")

    @staticmethod
    def dump_str(s: str, indent_level=1):
        indent = INDENT_PATTERN*indent_level
        print(f"{indent}{s}")

    @staticmethod
    def dump_titled_str(title: str, s: str, indent_level=1):
        indent = INDENT_PATTERN*indent_level
        s = s.replace("\n", " ")
        print(f"{indent}{title}={s}")

    @staticmethod
    def dump_titled_list(title: str, lst: List, indent_level=1):
        Dumpable.dump_title(title, indent_level)
        Dumpable.dump_list(lst, indent_level+1)

    @staticmethod
    def dump_list(lst: List, indent_level=1):
        indent = INDENT_PATTERN*indent_level
        for item in lst:
            if isinstance(item, dict):
                Dumpable.dump_dict(item, indent_level)
            else:
                sitem = str(item).replace('\n', ' ')
                print(f"{indent}{sitem}")

    @staticmethod
    def dump_titled_dict(title: str, dct: Dict, indent_level=1):
        Dumpable.dump_title(title, indent_level)
        Dumpable.dump_dict(dct, indent_level+1)

    @staticmethod
    def dump_dict(dct: Dict, indent_level=1):
        for key, val in dct.items():
            Dumpable.dump_titled(key, val, indent_level)

# Single entry elements


class SingleEntry(Dumpable, Extractable):

    def __init__(self, report: Dict, title: str, default_value):
        self.title = title
        self.content = report.get(title, default_value)

    def dump(self, indent_level=0):
        Bootloader.dump_titled(self.title, self.content, indent_level)

    def extract(self, root):
        Extractable.open_and_write(custom_path_join(root, self.title), self.content, True)


class Bootloader(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "bootloader", "")


class GroupsSystem(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "groups-system", [])


class PasswdSystem(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "passwd-system", [])


class BootEnv(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "boot-environment", {})


class DefaultTarget(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "default-target", "")


class Groups(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "groups", [])


class Hostname(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "hostname", "")


class MachineId(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "machine-id", "")


class OSRelease(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "os-release", {})


class Passwd(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "passwd", [])


class Timezone(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "timezone", "")


class ResolvConf(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "/etc/resolv.conf", [])


class ConfFolder(SingleEntry, Extractable):

    def dump(self, indent_level=0):
        Dumpable.dump_title(self.title, indent_level)
        for filename, filecontent in self.content.items():
            Dumpable.dump_titled(f"file {filename}", filecontent, indent_level+1)

    def extract(self, root):
        for filename, filecontent in self.content.items():
            Extractable.open_and_write(custom_path_join(root, filename),
                                       filecontent)


class Sudoers(ConfFolder):

    def __init__(self, report: Dict):
        super().__init__(report, "sudoers", {})


class Locale(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "locale", {})


class DnfAutomaticConf(SingleEntry):

    def __init__(self, report: Dict):
        super().__init__(report, "/etc/dnf/automatic.conf", {})


class SystemDLoginD(ConfFolder):

    def __init__(self, report: Dict):
        super().__init__(report, "systemd-logind", {})


class Hosts(SingleEntry):

    def __init__(self, report):
        super().__init__(report, "hosts", [])


class RpmNotInstalled(SingleEntry):

    def __init__(self, report):
        super().__init__(report, "rpm_not_installed_docs", [])

# Multiple entries elements


class ConstructedMultipleEntries(Dumpable, Extractable):

    def __init__(self, title: str):
        self.title = title
        self.has_content = True
        self.report_content = {}

    def dump(self, indent_level=1):
        Dumpable.dump_title(self.title)
        self.dump_all(indent_level)

    @abstractmethod
    def dump_all(self, indent_level):
        pass

    def extract(self, root):
        with Extractable.openf(custom_path_join(root, self.title), True) as f:
            self.extract_all(f)

    @abstractmethod
    def extract_all(self, f):
        pass


class MultipleEntries(ConstructedMultipleEntries):

    def __init__(self, report: Dict, title: str):
        super().__init__(title)
        self.report_content = report.get(title)
        self.has_content = title in report

    def get_list(self, name):
        if self.has_content:
            return self.report_content.get(name, [])
        return []

    def get_dict(self, name):
        if self.has_content:
            return self.report_content.get(name, {})
        return {}

    def get_str(self, name):
        if self.has_content:
            return self.report_content.get(name, "")
        return ""


class AuthselectConf(MultipleEntries):

    def __init__(self, report: Dict):
        super().__init__(report, "authselect")
        self.profile_id = self.get_str("profile-id")
        self.enabled_features = self.get_dict("enabled-features")

    def dump_all(self, indent_level):
        Dumpable.dump_titled("profile-id", self.profile_id, indent_level)
        Dumpable.dump_titled("enabled-features", self.enabled_features, indent_level)

    def extract_all(self, f):
        Extractable.write_titled(f, "[profile-id]", self.profile_id)
        Extractable.write_titled(f, "[enabled-features]", self.enabled_features)


class Chrony(MultipleEntries):

    def __init__(self, report: Dict):
        super().__init__(report, "chrony")
        self.leapsectz = self.get_dict("leapsectz")
        self.peer = self.get_dict("peer")
        self.pool = self.get_dict("pool")
        self.server = self.get_dict("server")

    def dump_all(self, indent_level):
        Dumpable.dump_titled("leapsectz", self.leapsectz, indent_level)
        Dumpable.dump_titled("peer", self.peer, indent_level)
        Dumpable.dump_titled("pool", self.pool, indent_level)
        Dumpable.dump_titled("server", self.server, indent_level)

    def extract_all(self, f):
        Extractable.write_titled(f, "[leapsectz]", self.leapsectz)
        Extractable.write_titled(f, "[peer]", self.peer)
        Extractable.write_titled(f, "[pool]", self.pool)
        Extractable.write_titled(f, "[server]", self.server)


class Dnf(MultipleEntries):

    def __init__(self, report: Dict):
        super().__init__(report, "DNF")
        self.dnf_conf = self.get_dict("dnf.conf")
        self.vars = self.get_dict("vars")

    def dump_all(self, indent_level):
        Dumpable.dump_titled("dnf.conf", self.dnf_conf, indent_level)
        Dumpable.dump_titled("vars", self.vars, indent_level)

    def extract_all(self, f):
        Extractable.write_titled(f, "[dnf.conf]", self.dnf_conf)
        Extractable.write_titled(f, "[vars]", self.vars)


class Keyboard(MultipleEntries):

    def __init__(self, report):
        super().__init__(report, "keyboard")
        self.x11 = self.get_dict("x11")
        self.vconsole = self.get_dict("vconsole")

    def dump_all(self, indent_level):
        Dumpable.dump_titled("x11", self.x11, indent_level)
        Dumpable.dump_titled("vconsole", self.vconsole, indent_level)

    def extract_all(self, f):
        Extractable.write_titled(f, "[x11]", self.x11)
        Extractable.write_titled(f, "[vconsole]", self.vconsole)


class TunedProfile(MultipleEntries):

    def __init__(self, report: Dict):
        super().__init__(report, "tuned")
        self.active_profile = self.get_str("active_profile")
        self.profile_mode = self.get_str("profile_mode")

    def dump_all(self, indent_level):
        Dumpable.dump_titled("active_profile", self.active_profile, indent_level)
        Dumpable.dump_titled("profile_mode", self.profile_mode, indent_level)

    def extract_all(self, f):
        Extractable.write_titled(f, "[active_profile]", self.active_profile)
        Extractable.write_titled(f, "[profile_mode]", self.profile_mode)


class RpmVerify(MultipleEntries):

    def __init__(self, report: Dict):
        super().__init__(report, "rpm-verify")
        self.changed = self.get_dict("changed")
        self.missing = self.get_list("missing")

    def dump_all(self, indent_level):
        Dumpable.dump_titled("changed", self.changed, indent_level)
        Dumpable.dump_titled("missing", self.missing, indent_level)

    def extract_all(self, f):
        Extractable.write_titled(f, "[changed]", self.changed)
        Extractable.write_titled(f, "[missing]", self.missing)


class Services(ConstructedMultipleEntries):

    def __init__(self, report: Dict):
        super().__init__("services")
        self.enabled = report["services-enabled"]
        self.disabled = report["services-disabled"]

    def dump_all(self, indent_level):
        Dumpable.dump_titled("services-enabled", self.enabled, indent_level)
        Dumpable.dump_titled("services-disabled", self.disabled, indent_level)

    def extract_all(self, f):
        Extractable.write_titled(f, "[services-enabled]", self.enabled)
        Extractable.write_titled(f, "[services-disabled]", self.disabled)


class Firewall(ConstructedMultipleEntries):

    def __init__(self, report):
        super().__init__("firewall")
        self.enabled = report.get("firewall-enabled", [])
        self.zone = report.get("firewall-default-zone", "")

    def dump_all(self, indent_level):
        Dumpable.dump_titled("firewall-enabled", self.enabled, indent_level)
        Dumpable.dump_titled("firewall-default-zone", self.zone, indent_level)

    def extract_all(self, f):
        Extractable.write_titled(f, "[firewall-enabled]", self.enabled)
        Extractable.write_titled(f, "[firewall-default-zone]", self.zone)


class ImageFormat(ConstructedMultipleEntries):

    def __init__(self, report: Dict):
        super().__init__("image-format")
        self.image_format = report["image-format"]["type"]
        self.compat = ""
        if self.image_format == "qcow2":
            self.compat = report["image-format"].get("compat")

    def dump_all(self, indent_level):
        Dumpable.dump_titled("image-format/type", self.image_format, indent_level)
        Dumpable.dump_titled("image-format/compat", self.compat, indent_level)

    def extract_all(self, f):
        Extractable.write_titled(f, "[image-format/type]", self.image_format)
        Extractable.write_titled(f, "[image-format/compat]", self.compat)


class OStree:

    def __init__(self, report: Dict):
        super().__init__("ostree")
        self.repo = report["ostree"]["repo"]
        self.refs = report["ostree"]["refs"]

    def dump_all(self, indent_level):
        Dumpable.dump_titled("ostree/repo", self.repo, indent_level)
        Dumpable.dump_titled("ostree/refs", self.refs, indent_level)

    def extract_all(self, f):
        Extractable.write_titled(f, "[ostree/repo]", self.repo)
        Extractable.write_titled(f, "[ostree/refs]", self.refs)


# configuration folder elements


class UdevRules(Dumpable, Extractable):

    def __init__(self, report: Dict):
        self.rules = {}
        if "/etc/udev/rules.d" in report:
            for file, rules in report["/etc/udev/rules.d"].items():
                self.rules[file] = rules

    def dump(self, indent_level=0):
        Dumpable.dump_titled("/etc/udev/rules.d", self.rules, indent_level)

    def extract(self, root):
        for filename, rules in self.rules.items():
            Extractable.open_and_write(
                custom_path_join(
                    root,
                    "/etc/udev/rules.d",
                    filename
                ),
                rules)


class MultiLevelConfFolder(Dumpable, Extractable):

    def __init__(self, report: Dict, keyname: str):
        self.title = keyname
        self.folder_content = {}
        for folder, content in report.get(keyname, {}).items():
            for file, config in content.items():
                if folder not in self.folder_content:
                    self.folder_content[folder] = {}
                self.folder_content[folder][file] = config

    def dump(self, indent_level=0):
        Dumpable.dump_title(self.title, indent_level)
        for folder, foldercontent in self.folder_content.items():
            Dumpable.dump_title(f"folder {folder}", indent_level+1)
            for file, content in foldercontent.items():
                Dumpable.dump_titled_list(f"file {file}",
                                          content,
                                          indent_level+2)

    def extract(self, root):
        for folder, foldercontent in self.folder_content.items():
            for file, content in foldercontent.items():
                Extractable.open_and_write(
                    custom_path_join(
                        root,
                        folder,
                        file),
                    content)


class CloudIinit(MultiLevelConfFolder):

    def __init__(self, report: Dict):
        super().__init__(report, "cloud-init")


class Dracut(MultiLevelConfFolder):

    def __init__(self, report: Dict):
        super().__init__(report, "dracut")


class SecurityLimits(MultiLevelConfFolder):

    def __init__(self, report: Dict):
        super().__init__(report, "security-limits")


class TmpFiles(MultiLevelConfFolder):

    def __init__(self, report: Dict):
        super().__init__(report, "tmpfiles")


class SSHConfig(MultiLevelConfFolder):

    def __init__(self, report: Dict):
        super().__init__(report, "ssh_config")


class SSHDConfig(MultiLevelConfFolder):

    def __init__(self, report: Dict):
        super().__init__(report, "sshd_config")


class SysctlD(MultiLevelConfFolder):

    def __init__(self, report: Dict):
        super().__init__(report, "sysctl.d")


class SystemDServiceDropin(MultiLevelConfFolder):

    def __init__(self, report: Dict):
        super().__init__(report, "systemd-service-dropins")


# Composed elements

class SELinuxContext(Dumpable, Extractable):

    def __init__(self, context: Dict):
        self.actual = context["actual"]
        self.expected = context["expected"]
        self.filename = context["filename"]

    def dump(self, indent_level=0):
        Dumpable.dump_titled("actual", self.actual, indent_level)
        Dumpable.dump_titled("expected", self.expected, indent_level)
        Dumpable.dump_titled("filename", self.filename, indent_level)

    def extract(self, root):
        with Extractable.openf(custom_path_join(root, "context-mismatch"), True) as f:
            Extractable.write_titled(f, "[actual]", self.actual)
            Extractable.write_titled(f, "[expected]", self.expected)
            Extractable.write_titled(f, "[filename]", self.filename)


class SELinux(MultipleEntries):

    def __init__(self, report: Dict):
        super().__init__(report, "selinux")
        self.policy = self.get_dict("policy")
        self.context_mismatch = []
        if self.has_content:
            for context in self.get_list("context-mismatch"):
                self.context_mismatch.append(SELinuxContext(context))

    def dump_all(self, indent_level):
        Dumpable.dump_titled("policy", self.policy, indent_level)
        Dumpable.dump_title("context-mismatch", indent_level)
        for slnxc in self.context_mismatch:
            slnxc.dump(indent_level+1)

    def extract_all(self, f):
        Extractable.write_titled(f, "[policy]", self.policy)
        for i, slnxc in enumerate(self.context_mismatch):
            slnxc.extract(custom_path_join(f"{f.name}.d", f"{i}"))


class BootEntry(Dumpable):

    def __init__(self, entry: Dict):
        self.entry = entry

    def dump(self, indent_level=0):
        Dumpable.dump_titled("boot-entry", self.entry, indent_level)


class BootMenu(Dumpable, Extractable):

    def __init__(self, report: Dict):
        self.boot_entries = []
        if "bootmenu" in report:
            for entry in report["bootmenu"]:
                self.boot_entries.append(BootEntry(entry))

    def dump(self, indent_level=0):
        Dumpable.dump_title("bootmenu", indent_level)
        for entry in self.boot_entries:
            entry.dump(indent_level+1)

    def extract(self, root):
        with Extractable.openf(custom_path_join(root, "bootmenu"), True) as f:
            for entry in self.boot_entries:
                Extractable.write_titled(f, "[boot-entry]", entry.entry)


class NetworkScript(Dumpable, Extractable):

    def __init__(self, name, configuration):
        self.name = name
        self.configuration = configuration

    def dump(self, indent_level=0):
        Dumpable.dump_titled("name", self.name, indent_level)
        Dumpable.dump_titled("configuration", self.configuration, indent_level)

    def extract(self, root):
        with Extractable.openf(custom_path_join(root, self.name), True) as f:
            Extractable.write_titled(f, "[configuration]", self.configuration)


class SysConfig(MultipleEntries):

    def __init__(self, report: Dict):
        super().__init__(report, "sysconfig")
        self.kernel = self.get_dict("kernel")
        self.network = self.get_dict("network")
        self.network_scripts = []
        if self.has_content:
            for iface, config in self.get_dict("network-scripts").items():
                self.network_scripts.append(NetworkScript(iface, config))

    def dump_all(self, indent_level):
        Dumpable.dump_titled("kernel", self.kernel, indent_level)
        Dumpable.dump_titled("network", self.network, indent_level)
        for ntscrpt in self.network_scripts:
            ntscrpt.dump(indent_level+1)

    def extract_all(self, f):
        Extractable.write_titled(f, "[kernel]", self.kernel)
        Extractable.write_titled(f, "[network]", self.network)
        for ntscrpt in self.network_scripts:
            ntscrpt.extract(custom_path_join(f"{f.name}.d"))


class RHSMConf(Dumpable, Extractable):

    def __init__(self, rhsm: Dict):
        self.logging = rhsm.get("logging")
        self.rhsm = rhsm.get("rhsm")
        self.rhsmcertd = rhsm.get("rhsmcertd")
        self.server = rhsm.get("server")

    def dump(self, indent_level=0):
        Dumpable.dump_titled("logging", self.logging, indent_level)
        Dumpable.dump_titled("rhsm", self.rhsm, indent_level)
        Dumpable.dump_titled("rhsmcertd", self.rhsmcertd, indent_level)
        Dumpable.dump_titled("server", self.server, indent_level)

    def extract(self, root):
        with Extractable.openf(custom_path_join(root, "rhsm_conf"), True) as f:
            Extractable.write_titled(f, "[logging]", self.logging)
            Extractable.write_titled(f, "[rhsm]", self.rhsm)
            Extractable.write_titled(f, "[rhsmcertd]", self.rhsmcertd)
            Extractable.write_titled(f, "[server]", self.server)


class DnfPluginsConfig(Dumpable):

    def __init__(self, product_id, subscription_manager):
        self.product_id = "true" in product_id
        self.subscription_manager = "true" in subscription_manager

    def dump(self, indent_level=0):
        Dumpable.dump_title("dnf-plugins", indent_level)
        Dumpable.dump_titled("product-id", self.product_id, indent_level+1)
        Dumpable.dump_titled("subscription-manager", self.subscription_manager,
                             indent_level+1)

    def extract(self, root):
        with Extractable.openf(custom_path_join(root, "dnf_plugins"), True) as f:
            Extractable.write_titled(f, "[product-id]", self.product_id)
            Extractable.write_titled(f, "[subscription-manager]", self.subscription_manager)


class RHSM(MultipleEntries):

    def __init__(self, report: Dict):
        super().__init__(report, "rhsm")
        self.rhsm_conf = self.get_dict("rhsm.conf")
        self.dnf_plugins = None
        if self.has_content:
            if "dnf-plugins" in self.report_content:
                self.dnf_plugins = DnfPluginsConfig(
                    self.report_content["dnf-plugins"]["product-id"],
                    self.report_content["dnf-plugins"]["subscription-manager"])

    def dump_all(self, indent_level):
        Dumpable.dump_titled("rhsm.conf", self.rhsm_conf, indent_level)
        if self.dnf_plugins:
            self.dnf_plugins.dump()

    def extract_all(self, f):
        Extractable.write_titled(f, "[rhsm.conf]", self.rhsm_conf)
        if self.dnf_plugins:
            self.dnf_plugins.extract(custom_path_join(f"{f.name}.d"))


class BlacklistModule(Dumpable, Extractable):

    def __init__(self, path: str, blacklist: List):
        self.path = path
        self.blacklist = blacklist

    def dump(self, indent_level=0):
        Dumpable.dump_titled("path", self.path, indent_level)
        Dumpable.dump_titled("blacklist", self.blacklist, indent_level+1)

    def extract(self, root):
        Extractable.open_and_write(custom_path_join(root, self.path), self.blacklist, True)


class Modprobe(Dumpable, Extractable):

    def __init__(self, report: Dict):
        self.folder_conf = {}
        if "modprobe" in report:
            for folder, content in report["modprobe"].items():
                for path, blacklist in content.items():
                    self.folder_conf[folder] = BlacklistModule(path, blacklist)

    def dump(self, indent_level=0):
        Dumpable.dump_title("Modprobe", indent_level)
        for folder, bl in self.folder_conf.items():
            Dumpable.dump_title(folder, indent_level+1)
            bl.dump(indent_level+2)

    def extract(self, root):
        for folder, bl in self.folder_conf.items():
            bl.extract(custom_path_join(root, folder))


class Package(Dumpable):

    def __init__(self, package: str):
        self.package_name = package.split(".")[0]
        self.version = ".".join(package.split(".")[1:])

    def dump(self, indent_level=0):
        Dumpable.dump_str(f"{self.package_name} @version {self.version}", indent_level)

    def __str__(self):
        return f"{self.package_name}.{self.version}"

    def __lt__(self, other):
        if self.package_name == other.package_name:
            return self.version < other.version
        return self.package_name < other.package_name


class Packages(Dumpable, Extractable):

    def __init__(self, report: Dict):
        self.packages = []
        for package in report.get("packages", []):
            self.packages.append(Package(package))

    def dump(self, indent_level=0):
        Dumpable.dump_title("packages")
        for pkg in self.packages:
            pkg.dump(indent_level+1)

    def extract(self, root):
        Extractable.open_and_write(custom_path_join(root, "packages"), self.packages, True)

    def diff(self, other):
        missing_other = []
        missing_me = []
        different = []
        for package in self.packages:
            other_package = other.find_package(package.package_name)
            if not other_package:
                missing_other.append(package)
            else:
                if package.version != other_package.version:
                    different.append(package)
        for package in other.packages:
            my_package = self.find_package(package.package_name)
            if not my_package:
                missing_me.append(package)
        missing_me.sort()
        missing_other.sort()
        different.sort()
        return missing_me, missing_other, different

    def find_package(self, pkg_name):
        for package in self.packages:
            if package.package_name == pkg_name:
                return package
        return None


class Repo(Dumpable, Extractable):

    def __init__(self, name, repo):
        self.name = name
        self.baseurl = repo.get("baseurl", "")
        self.enabled = repo.get("enabled", "")
        self.gpgkey = repo.get("gpgkey", "")
        self.name = repo.get("name", "")
        self.repo_gpgcheck = repo.get("repo_gpgcheck", "")

    def dump(self, indent_level=0):
        Dumpable.dump_title(self.name, indent_level)
        Dumpable.dump_titled("baseurl", self.baseurl, indent_level+1)
        Dumpable.dump_titled("enabled", self.enabled, indent_level+1)
        Dumpable.dump_titled("gpgkey", self.gpgkey, indent_level+1)
        Dumpable.dump_titled("name", self.name, indent_level+1)
        Dumpable.dump_titled("repo_gpgcheck", self.repo_gpgcheck, indent_level+1)

    def extract(self, root):
        with Extractable.openf(custom_path_join(root, self.name), True) as f:
            Extractable.write_titled(f, "[baseurl]", self.baseurl)
            Extractable.write_titled(f, "[enabled]", self.enabled)
            Extractable.write_titled(f, "[gpgkey]", self.gpgkey)
            Extractable.write_titled(f, "[name]", self.name)
            Extractable.write_titled(f, "[repo_gpgcheck]", self.repo_gpgcheck)


class YumRepos(Dumpable, Extractable):

    def __init__(self, report: Dict):
        self.repos = {}
        if "yum_repos" in report:
            for file, repo in report["yum_repos"].items():
                if file not in self.repos:
                    self.repos[file] = {}
                for rep, repos_content in repo.items():
                    if rep not in self.repos[file]:
                        self.repos[file][rep] = []
                    for name, info in repos_content.items():
                        self.repos[file][rep].append(Repo(name, info))

    def dump(self, indent_level=0):
        Dumpable.dump_title("yum-repos", indent_level)
        for file, repos in self.repos.items():
            Dumpable.dump_title(file, indent_level+1)
            for r, lst in repos.items():
                Dumpable.dump_title(r, indent_level+2)
                for repo in lst:
                    repo.dump(indent_level+3)

    def extract(self, root):
        for file, repos in self.repos.items():
            for r, lst in repos.items():
                for repo in lst:
                    repo.extract(custom_path_join(root, file, r))


class FStabEntry(Dumpable):

    def __init__(self, entry: List):
        self.info = entry

    def dump(self, indent_level=0):
        Dumpable.dump_titled("fstab-entry", self.info, indent_level)

    def __str__(self):
        return " ".join(self.info)


class FStab(Dumpable, Extractable):

    def __init__(self, report):
        self.entries = []
        if "fstab" in report:
            for entry in report["fstab"]:
                self.entries.append(FStabEntry(entry))

    def dump(self, indent_level=0):
        Dumpable.dump_title("fstab", indent_level)
        for entry in self.entries:
            entry.dump(indent_level+1)

    def extract(self, root):
        with Extractable.openf(custom_path_join(root, "fstab"), True) as f:
            for entry in self.entries:
                Extractable.write_all(f, entry)


class Partition(Dumpable, Extractable):

    def __init__(self, report: Dict):
        self.bootable = report["bootable"]
        self.partuuid = report["partuuid"]
        self.size = report["size"]
        self.type = report["type"]

    def dump(self, indent_level=0):
        Dumpable.dump_titled("bootable", self.bootable, indent_level)
        Dumpable.dump_titled("partuuid", self.partuuid, indent_level)
        Dumpable.dump_titled("size", self.size, indent_level)
        Dumpable.dump_titled("type", self.type, indent_level)

    def extract(self, root):
        with Extractable.openf(custom_path_join(root, self.partuuid), True) as f:
            Extractable.write_titled(f, "[bootable]", self.bootable)
            Extractable.write_titled(f, "[partuuid]", self.partuuid)
            Extractable.write_titled(f, "[size]", self.size)
            Extractable.write_titled(f, "[type]", self.type)


class Partitions(Dumpable, Extractable):

    def __init__(self, report: Dict):
        self.partition_table = ""
        self.partition_table_id = ""
        self.partitions = []
        if report.get("partition-table"):
            self.partition_table = report["partition-table"]
            self.partition_table_id = report["partition-table-id"]
            for item in report["partitions"]:
                self.partitions.append(Partition(item))

    def dump(self, indent_level=0):
        Dumpable.dump_titled("partition-table", self.partition_table, indent_level)
        Dumpable.dump_titled("partition-table-id", self.partition_table_id, indent_level)
        Dumpable.dump_title("partitions", indent_level)
        for partition in self.partitions:
            partition.dump(indent_level+1)

    def extract(self, root):
        with Extractable.openf(custom_path_join(root, "partitions"), True) as f:
            Extractable.write_titled(f, "[partition-table]", self.partition_table)
            Extractable.write_titled(f, "[partition-table-id]", self.partition_table_id)
            for partition in self.partitions:
                partition.extract(custom_path_join(root, "partitions.d"))

# entry point classes


class ImageInfo(Dumpable, Extractable):

    def __init__(self, report, name):
        self.name = name
        self.report_content = {
            "authselect": AuthselectConf(report),
            "boot-environment": BootEnv(report),
            "bootmenu": BootMenu(report),
            "chrony": Chrony(report),
            "cloud-init": CloudIinit(report),
            "default-target": DefaultTarget(report),
            "dnf": Dnf(report),
            "dnf_automatic_conf": DnfAutomaticConf(report),
            "dracut": Dracut(report),
            "firewall": Firewall(report),
            "fstab": FStab(report),
            "groups": Groups(report),
            "hostname": Hostname(report),
            "hosts": Hosts(report),
            "keyboad": Keyboard(report),
            "locale": Locale(report),
            "machine-id": MachineId(report),
            "modprobe": Modprobe(report),
            "os-release": OSRelease(report),
            "packages": Packages(report),
            "passwd": Passwd(report),
            "resolv-conf": ResolvConf(report),
            "rhsm": RHSM(report),
            "rpm-not-installed-docs": RpmNotInstalled(report),
            "rpm-verify": RpmVerify(report),
            "security-limits": SecurityLimits(report),
            "selinux": SELinux(report),
            "services": Services(report),
            "ssh-configs": SSHConfig(report),
            "sshd-configs": SSHDConfig(report),
            "sudoers-conf": Sudoers(report),
            "sysconfig": SysConfig(report),
            "sysctld-configs": SysctlD(report),
            "systemd-logind": SystemDLoginD(report),
            "systemd-service-dropins": SystemDServiceDropin(report),
            "timezone": Timezone(report),
            "tmpfiles-d": TmpFiles(report),
            "tuned-profile": TunedProfile(report),
            "udev-rules": UdevRules(report),
            "yum-repos": YumRepos(report)
        }

    @classmethod
    def get_imi(cls, report: Dict, name):
        if report is None:
            return None
        if (report.get("type", None) == "ostree/commit" or
                report.get("type", None) == "ostree/repo"):
            # image-info represents a ostree repo
            return OSTreeInfoImage(report, name)
        if report.get("bootloader", None):
            # image-info represents an image
            return ImageInfoImage(report, name)
        # image-info represents a directory
        return DirectoryInfoImage(report, name)

    def dump(self, indent_level=0):
        print(f"Image Info content: {self.name}")
        for _, obj in self.report_content.items():
            obj.dump(indent_level+1)

    def extract(self, root):
        print(f"Extracting {self.name} to {root}")
        for _, obj in self.report_content.items():
            obj.extract(root)


class ImageInfoImage(ImageInfo):

    def __init__(self, report, name):
        super().__init__(report, name)
        self.report_content["partitions"] = Partitions(report)
        self.report_content["image-format"] = ImageFormat(report)
        self.report_content["bootloader"] = Bootloader(report)


class OSTreeInfoImage(ImageInfo):

    def __init__(self, report, name):
        super().__init__(report, name)
        self.report_content["ostree"]: OStree(report)
        self.report_content["groups-system"]: GroupsSystem(report)
        self.report_content["passwd-system"]: PasswdSystem(report)


class DirectoryInfoImage(ImageInfo):
    pass


def load_input(filename, short_name, filetype):
    with open(filename, encoding="utf-8") as f:
        if filetype == "only":
            return ImageInfoImage.get_imi(json.load(f), short_name)
        return ImageInfoImage.get_imi(json.load(f)["image-info"], short_name)


def main():
    parser = argparse.ArgumentParser(description="Inspect an image")
    group = parser.add_mutually_exclusive_group()
    group.add_argument("--input-folder",
                       type=os.path.abspath,
                       help="a folder containing files with the image-info "
                       "the tool will loop over each files")
    group.add_argument("--input",
                       action="append",
                       type=os.path.abspath,
                       help="a file containing the image-info")
    parser.add_argument("--input-type",
                        type=str,
                        choices=["only", "test_case"],
                        default="test_case",
                        help="input contains image info only or embedded in a test case")
    parser.add_argument("--command",
                        type=str,
                        choices=["dump", "extract", "diff"],
                        default="dump",
                        help="what to do with each files")
    parser.add_argument("--output-folder",
                        type=str,
                        help="the folder to store the output of extract"
                        " default will be in /tmp/$random/filename")
    parser.add_argument("--diff-option",
                        type=str,
                        choices=["packages"],
                        default="dump",
                        help="what to do with each files")

    args = parser.parse_args()
    filenames = args.input
    if args.input_folder:
        filenames = next(walk(args.input_folder), (None, None, []))[2]
        filenames = [f'{args.input_folder}/{f}' for f in filenames]
    if "extract" in args.command:
        if args.output_folder:
            outputf = args.output_folder
        else:
            outputf = tempfile.mkdtemp()
        print(f"global output folder: {outputf}")
    imis = []
    for filename in filenames:
        short_name = filename.split("/")[-1]
        imi = load_input(filename, short_name, args.input_type)
        if imi:
            if "dump" in args.command:
                imi.dump()
            if "extract" in args.command:
                output_folder = custom_path_join(outputf, short_name)
                os.makedirs(output_folder, exist_ok=True)
                imi.extract(output_folder)
            imis.append(imi)
    if "diff" in args.command:
        if len(filenames) != 2:
            print("diff requires exactly two input files")
            return
        if "packages" in args.diff_option:
            diff_packages(imis[0], imis[1])


def diff_packages(imi1: ImageInfo, imi2: ImageInfo):
    packages1 = imi1.report_content["packages"]
    packages2 = imi2.report_content["packages"]
    missing1, missing2, different = packages1.diff(packages2)
    if missing1:
        print(f"The following packages were missing from {imi1.name}:")
        for package1 in missing1:
            print(f"    {package1.package_name}")
    if missing2:
        print(f"The following packages were missing from {imi2.name}:")
        for package2 in missing2:
            print(f"    {package2.package_name}")
    if different:
        print(f"The following packages are not on the same version: ({imi1.name}) != ({imi2.name})")
        for package1 in different:
            package2 = packages2.find_package(package1.package_name)
            print(f"    {package1.package_name}, version {package1.version}"
                  f" != {package2.version}")


if __name__ == "__main__":
    main()
