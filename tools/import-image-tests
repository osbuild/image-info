#!/usr/bin/python3
"""
Import Composer image tests
"""

import argparse
import json
import os
import yaml

from typing import Iterator, Tuple


RESET = "\033[0m"
GREEN = "\033[32m"
BOLD = "\033[1m"
RED = "\033[31m"


def parse_name(name: str):
    comps = name.split("-")
    distro = comps[0]
    arch = comps[1]
    name = comps[2]
    extra = comps[3] if len(comps) > 3 else None
    return distro, arch, name, extra


def list_tests(source) -> Iterator[Tuple[str, str]]:
    for entry in os.scandir(source):
        if not entry.is_file():
            continue
        if not entry.name.endswith(".json"):
            continue

        name = entry.name[:-5]
        fullpath = os.path.join(source, entry.name)
        yield name, fullpath


def load_test(name, fullpath, filters) -> dict:
    with open(fullpath, "r", encoding="utf-8") as f:
        data = json.load(f)

    manifest = data.get("manifest")
    if not manifest:
        raise ValueError("no manifest")

    req = data.get("compose-request")
    if not req:
        raise ValueError("no compose-request")

    distros, archs = list(map(list, zip(*filters)))
    if req["distro"] not in distros or req["arch"] not in archs:
        return None

    test = {
        "id": name,
        "desc": {
            "distro": req["distro"],
            "arch": req["arch"],
            "image-type": req["image-type"],
        },
        "manifest": data["manifest"],
        "image-info": data.get("image-info"),
    }

    return test


def export_test(test, target, manifest_only):
    name = test["id"]
    fullpath = os.path.join(target, name + ".json")
    if manifest_only and os.path.exists(fullpath):
        # load existing
        with open(fullpath, "r", encoding="utf-8") as f:
            base = json.load(f)
        base["manifest"] = test["manifest"]
        test = base
    with open(fullpath, "w", encoding="utf-8") as f:
        json.dump(test, f, indent=2)


def report_import(test, verbosity=1):
    if verbosity < 1:
        return

    if verbosity == 1:
        print(".", end="", flush=True)
    else:
        print(f"{GREEN} OK  {RESET} {test['id']}", flush=True)


def report_failure(name, reason, verbosity=1):
    if verbosity < 1:
        return

    if verbosity == 1:
        print(f"{RED}F{RESET}", end="", flush=True)
    else:
        print(f"{RED}FAIL{RESET} {name}: {reason}")


def main():
    parser = argparse.ArgumentParser(description="osbuild image tests")
    parser.add_argument(
        "SOURCE",
        metavar="DIRECTORY",
        type=os.path.abspath,
        help="directory where test cases are imported from")
    parser.add_argument(
        "TARGET",
        metavar="DIRECTORY",
        type=os.path.abspath,
        default=None,
        help="directory where test cases are exported to")
    parser.add_argument(
        "--dry-run",
        action="store_true",
        default=False,
        help="do not export test cases"
    )
    parser.add_argument(
        "--manifest-only",
        action="store_true",
        default=False,
        help="Only import the manifests from composer"
    )
    parser.add_argument(
        "--filter-with-ci-distros",
        type=os.path.abspath,
        default=None,
        help="filter the importations from composer based on the distros coming from CI yml file"
    )
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        "--verbose",
        dest="verbosity",
        action="count",
        default=1,
        help="increase verbosity")
    group.add_argument(
        "--quiet",
        action="store_const",
        const=0,
        dest="verbosity",
        help="suppress output")
    parser.add_argument(
        "--db-ignore",
        type=os.path.abspath,
        default=None,
        help="A file containing one per line file names not to import")

    args = parser.parse_args()

    db_ignore = []
    if args.db_ignore:
        with open(args.db_ignore, "r", encoding="utf-8") as f:
            db_ignore = f.read().splitlines()
        print("Filtering manifests, ignoring:")
        for dbi in db_ignore:
            print(f"    - {dbi}")

    filters = []
    if args.filter_with_ci_distros:
        print("Filtering distros, importing only:")
        with open(args.filter_with_ci_distros, "r", encoding="utf-8") as f:
            data = yaml.load(f, Loader=yaml.Loader)
            runners = data["Manifests"]["parallel"]["matrix"]
            for runner in runners:
                for machine_id in runner["RUNNER"]:
                    flavor = machine_id.split("/")[-1]
                    arch = flavor.split("-")[-1]
                    distro = ""
                    if "fedora" in flavor:
                        distro = f"fedora-{flavor.split('-')[1]}"
                    elif "centos" in flavor:
                        distro = f"centos-{flavor.split('-')[2]}"
                    elif "rhel" in flavor:
                        distro = f"rhel-{flavor.split('-')[1].replace('.', '')}"
                    print(f"    - {distro} {arch}")
                    filters.append((distro,arch))

    idx = 0
    failures = []

    print("Running import:")
    for idx, (name, path) in enumerate(list_tests(args.SOURCE)):
        try:
            if name in db_ignore:
                continue

            test = load_test(name, path, filters)

            if not test:
                continue

            if args.dry_run:
                continue

            export_test(test, args.TARGET, args.manifest_only)
        except ValueError as e:
            report_failure(name, str(e), args.verbosity)
            failures.append(name)
        else:
            report_import(test, args.verbosity)

    print(f"\n{GREEN}{idx + 1 - len(failures) }{RESET} tests imported")
    if failures:
        print(f"{RED}{len(failures)}{RESET} failed")


if __name__ == "__main__":
    main()
