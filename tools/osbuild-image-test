#!/usr/bin/python3
"""
OSBuild image based tests
"""

import argparse
import fnmatch
import json
import os
import platform
import subprocess
import sys
import traceback
import shutil

from collections import defaultdict
from typing import Iterator, List, Optional

import osbuild
import osbuild.meta


RESET = "\033[0m"
GREEN = "\033[32m"
BOLD = "\033[1m"
RED = "\033[31m"
YELLOW = "\033[33m"


def show_validation(result, name="validation"):

    print(f"{BOLD}{name}{RESET} ", end='')

    if result:
        print(f"is {BOLD}{GREEN}valid{RESET}")
        return

    print(f"has {BOLD}{RED}errors{RESET}:")
    print("")

    for error in result:
        print(f"{BOLD}{error.id}{RESET}:")
        print(f"  {error.message}\n")


class OSBuild:
    def __init__(self, path, store, outdir):
        self.path = path
        self.store = store
        self.outdir = outdir
        self.checkpoints = []
        self.verbosity = 1

    def compile(self, manifest: dict, exports: List, checkpoints=None):
        res = self.run([],
                       manifest=manifest,
                       exports=exports,
                       checkpoints=checkpoints)
        return res

    def inspect(self, manifest: dict) -> dict:
        return self.run(args=["--inspect"], manifest=manifest)

    def run(self,
            args: Optional[List[str]] = None,
            manifest: Optional[dict] = None,
            exports: Optional[List] = None,
            checkpoints: Optional[List] = None):

        cmd = [
            self.path,
            "--store", os.fspath(self.store),
            "--output-dir", os.fspath(self.outdir),
            "--json",
        ]

        if args:
            cmd += args

        for checkpoint in self.checkpoints + (checkpoints or []):
            cmd += [
                "--checkpoint", checkpoint
            ]

        for export in (exports or []):
            cmd += [
                "--export", export
            ]

        data = None
        if manifest:
            data = json.dumps(manifest, indent=2).encode("utf-8")
            cmd += [
                "-",
            ]

        if self.verbosity > 1:
            print("+" + " ".join(cmd), file=sys.stderr)

        r = subprocess.run(cmd,
                           check=False,
                           input=data,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE)

        if r.returncode != 0:
            stdout = r.stdout.decode("utf-8").strip()

            try:
                data = json.loads(stdout)
            except json.JSONDecodeError:
                msg = r.stderr.decode("utf-8").strip()
                msg += r.stdout.decode("utf-8").strip()
            else:
                msg = data.get("title")

            msg = r.stderr.decode("utf-8").strip()
            msg += r.stdout.decode("utf-8").strip()
            raise RuntimeError("osbuild failed: " + msg)

        return json.loads(r.stdout.decode("utf-8"))


class ImageInfo:
    def __init__(self, path: str):
        self.path = path
        self.verbosity = 1

    def run(self, target: str):
        cmd = [
            self.path,
            target
        ]

        if self.verbosity > 1:
            print("+" + " ".join(cmd), file=sys.stderr)

        r = subprocess.run(cmd,
                           check=False,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE)

        if r.returncode != 0:
            msg = r.stderr.decode("utf-8").strip()
            msg += r.stdout.decode("utf-8").strip()
            raise RuntimeError("image-info failed: " + msg)

        return json.loads(r.stdout.decode("utf-8"))


class TestCase:
    def __init__(self, path, data: dict) -> None:
        self.path = path
        self.id = data["id"]
        self.info = data["desc"]
        self.desc = data["manifest"]
        self.image_info = data.get("image-info")

        self.manifest: Optional[osbuild.Manifest] = None
        self.result: Optional[dict] = None
        self.error: Optional[str] = None

    def __str__(self):
        res = str(self.id)
        extra = []

        if not self.image_info:
            extra += ["no-image-info"]

        if extra:
            res += f" [{', '.join(extra)}]"

        return res

    @classmethod
    def load(cls, path: str) -> "TestCase":
        with open(path, "r", encoding='utf8') as f:
            data = json.load(f)

        return cls(path, data)

    def load_manifest(self, index: osbuild.meta.Index, verbose=False) -> bool:
        info = index.detect_format_info(self.desc)
        if not info:
            self.error = "Unsupported manifest format"
            return False

        fmt = info.module

        try:
            res = fmt.validate(self.desc, index)
            if not res:
                if verbose:
                    show_validation(res)
                self.error = "Invalid manifest: validation failed"
                return False

            self.manifest = fmt.load(self.desc, index)
        except Exception as e:  # pylint: disable=broad-except
            if verbose:
                print(traceback.format_exc())
            self.error = f"EXCEPTION: {e}"
            return False

        return True


class ImageTestSuite:
    pass


def load_tests(path) -> Iterator[TestCase]:
    files = os.scandir(path)

    for entry in files:
        if not entry.is_file():
            continue

        fullpath = os.path.join(path, entry.name)
        case = TestCase.load(fullpath)
        yield case


def detect_exports(test: TestCase) -> List[str]:

    pipelines = test.manifest.pipelines
    if not pipelines:
        return []

    # for now we just assume the last pipeline is the export
    return [next(reversed(pipelines))]


def detect_checkpoints(test: TestCase) -> List[str]:
    checkpoints = []
    manifest = test.manifest

    build = manifest.get("build")
    if build:
        checkpoints += [build.name]

    commit = manifest.get("ostree-commit")
    if commit:
        checkpoints += [commit.name]

    return checkpoints


def build_image(test: TestCase, osb: OSBuild, args: argparse.Namespace) -> bool:
    exports = detect_exports(test)
    # construct the result path
    pipeline = test.manifest.pipelines[exports[0]]
    # assume if there's no filename in the last stage that image.raw will work
    filename = pipeline.stages[-1].options.get("filename", "image.raw")
    image_path = os.path.join(osb.outdir, exports[0], filename)

    checkpoints = detect_checkpoints(test)

    try:
        if args.dry_run:
            return True

        result = osb.run(manifest=test.desc,
                         exports=exports,
                         checkpoints=checkpoints)
        test.result = result
        test.result["image"] = image_path

        return True
    except RuntimeError as e:
        test.error = str(e)
        return False


def write_json(name, result, folder):
    os.makedirs(folder, exist_ok=True)
    with open(os.path.join(folder, f"{name}.json"), "w", encoding="utf-8") as f:
        json.dump(result, f)

# pylint: disable=[too-many-return-statements]


def inspect_image(test: TestCase, imi: ImageInfo, args: argparse.Namespace) -> bool:
    if args.dry_run:
        return True

    if "image" not in test.result:
        test.error = "image not produced"
        return False
    if not os.path.exists(test.result["image"]):
        test.error = f"image {test.result['image']} not found"
        return False

    try:
        result = imi.run(test.result["image"])
        test.result = result
    except RuntimeError as e:
        test.error = str(e)
        return False

    write_json(test.id, result, args.image_info_output)

    if not args.skip_inspection :
        if not test.image_info:
            print(f" {YELLOW}Warning{RESET}: No image info to compare to; ", end="")
            return True

        if result != test.image_info:
            test.error = "image-info mismatch"
            return False

    return True


def make_filter(args):
    def fn(test):
        info = test.info

        if args.arch and info["arch"] != args.arch:
            return False

        if args.distro and info["distro"] != args.distro:
            return False

        if args.name:
            return fnmatch.fnmatch(test.id, args.name)

        return True

    return fn


def print_stats(tests: List[TestCase]) -> None:
    distors = defaultdict(int)
    archs = defaultdict(int)
    types = defaultdict(int)

    for test in tests:
        print(test)
        distors[test.info["distro"]] += 1
        archs[test.info["arch"]] += 1
        types[test.info["image-type"]] += 1

    print("Distributions:")
    for distro, count in sorted(distors.items()):
        print(f"\t{distro}: {count}")

    print("Architectures:")
    for arch, count in sorted(archs.items()):
        print(f"\t{arch}: {count}")

    print("Image types:")
    for image_type, count in sorted(types.items()):
        print(f"\t{image_type}: {count}")


def run_test(test, osb: OSBuild, imi: ImageInfo, args):
    print(f"{test.id}", end="", flush=True)
    if test.error:
        print(f" {YELLOW}Warning (ignoring){RESET}: {test.error}")
        return True

    if args.skip_inspection:
        print(f"{YELLOW}Building only{RESET}: ", end="", flush=True)

    if not build_image(test, osb, args):
        print(f" {RED}FAIL{RESET}: {test.error}")
        return False

    if test.error:
        print(f" {RED}FAIL{RESET}: {test.error}")
        return False

    if not inspect_image(test, imi, args):
        print(f" {RED}FAIL{RESET}: {test.error}")
        return False

    print(f" {GREEN}SUCCESS{RESET}")
    return True


def clean_output(output):
    """
    Empty the output folder as it can get quite big after a few runs.
    """
    for root, dirs, files in os.walk(output):
        for f in files:
            os.unlink(os.path.join(root, f))
        for d in dirs:
            shutil.rmtree(os.path.join(root, d))


def main():
    parser = argparse.ArgumentParser(description="osbuild image tests")
    parser.add_argument("--osbuild-path",
                        metavar="PATH",
                        type=os.path.abspath,
                        dest="osbuild",
                        default="/usr/bin/osbuild",
                        help="path to the osbuild executable"
                        )
    parser.add_argument(
        "--image-info-path",
        metavar="PATH",
        type=os.path.abspath,
        dest="image_info",
        default="tools/image-info",
        help="path to the image-info executable"
    )
    parser.add_argument(
        "--tempdir",
        metavar="DIRECTORY",
        type=os.path.abspath,
        default="/var/lib/osbuild-tests",
        help="directory where intermediary files will be stored")
    parser.add_argument(
        "--store",
        metavar="DIRECTORY",
        type=os.path.abspath,
        default="/var/lib/osbuild/store",
        help="directory where intermediary os trees are stored")
    parser.add_argument(
        "--output",
        metavar="DIRECTORY",
        type=os.path.abspath,
        default="/var/lib/osbuild/out",
        help="directory where result objects are stored")
    parser.add_argument(
        "--image-info-output",
        metavar="DIRECTORY",
        type=os.path.abspath,
        default="generated-image-infos/",
        help="directory where produced image info JSON will be stored")
    parser.add_argument(
        "--arch",
        metavar="ARCHITECTURE",
        type=str,
        default=platform.machine(),
        help="filter tests by architecture [default: host]")
    parser.add_argument(
        "--distro",
        metavar="DISTRIBUTION",
        type=str,
        help="filter tests by distribution")
    parser.add_argument(
        "--name",
        metavar="NAME",
        type=str,
        help="filter tests by name"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        default=False,
        help="Do not compile test cases"
    )
    parser.add_argument(
        "-l", "--libdir",
        metavar="DIRECTORY",
        type=os.path.abspath,
        default="/usr/lib/osbuild",
        help="directory containing the osbuild modules and library"
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        default=False,
        help="output more info"
    )
    parser.add_argument(
        "--skip-inspection",
        action="store_true",
        default=False,
        help="Disengage comparison of the built images to their reference in the DB"
    )

    args = parser.parse_args()

    index = osbuild.meta.Index(args.libdir)

    print(f"Running in {os.path.realpath(os.curdir)}")

    tests = list(load_tests("manifest-db"))
    tests = list(filter(make_filter(args), tests))

    if not tests:
        print(f" {RED}FAIL{RESET}: no tests to run")
        return 1

    for t in tests:
        print(f"{t.id}", end="", flush=True)

        res = t.load_manifest(index, verbose=args.verbose)
        if not res:
            print(f" {RED}FAIL{RESET}: {t.error}", end="")

        print("")

    print_stats(tests)

    osb = OSBuild(args.osbuild, args.store, args.output)
    imi = ImageInfo(args.image_info)

    success = True
    for t in tests:
        if not run_test(t, osb, imi, args):
            success = False
        clean_output(args.output)

    return 1 if not success else 0


if __name__ == "__main__":
    sys.exit(main())
