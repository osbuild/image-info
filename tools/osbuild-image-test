#!/usr/bin/python3
"""
OSBuild image based tests
"""

import argparse
import fnmatch
import json
import os
import platform
import subprocess
import sys
import traceback
import shutil

from collections import defaultdict
from typing import Iterator, List, Optional

import osbuild
import osbuild.meta


RESET = "\033[0m"
GREEN = "\033[32m"
BOLD = "\033[1m"
RED = "\033[31m"
YELLOW = "\033[33m"


def show_validation(result, name="validation"):

    print(f"{BOLD}{name}{RESET} ", end='')

    if result:
        print(f"is {BOLD}{GREEN}valid{RESET}")
        return

    print(f"has {BOLD}{RED}errors{RESET}:")
    print("")

    for error in result:
        print(f"{BOLD}{error.id}{RESET}:")
        print(f"  {error.message}\n")


class OSBuild:
    def __init__(self, path, store, outdir):
        self.path = path
        self.store = store
        self.outdir = outdir
        self.checkpoints = []
        self.verbosity = 1

    def compile(self, manifest: dict, exports: List, checkpoints=None):
        res = self.run([],
                       manifest=manifest,
                       exports=exports,
                       checkpoints=checkpoints)
        return res

    def inspect(self, manifest: dict) -> dict:
        return self.run(args=["--inspect"], manifest=manifest)

    def run(self,
            args: Optional[List[str]] = None,
            manifest: Optional[dict] = None,
            exports: Optional[List] = None,
            checkpoints: Optional[List] = None):

        cmd = [
            self.path,
            "--store", os.fspath(self.store),
            "--output-dir", os.fspath(self.outdir),
            "--json",
        ]

        if args:
            cmd += args

        for checkpoint in self.checkpoints + (checkpoints or []):
            cmd += [
                "--checkpoint", checkpoint
            ]

        for export in (exports or []):
            cmd += [
                "--export", export
            ]

        data = None
        if manifest:
            data = json.dumps(manifest, indent=2).encode("utf-8")
            cmd += [
                "-",
            ]

        if self.verbosity > 1:
            print("+" + " ".join(cmd), file=sys.stderr)

        r = subprocess.run(cmd,
                           check=False,
                           input=data,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE)

        if r.returncode != 0:
            stdout = r.stdout.decode("utf-8").strip()

            try:
                data = json.loads(stdout)
            except json.JSONDecodeError:
                msg = r.stderr.decode("utf-8").strip()
                msg += r.stdout.decode("utf-8").strip()
            else:
                msg = data.get("title")

            msg = r.stderr.decode("utf-8").strip()
            msg += r.stdout.decode("utf-8").strip()
            raise RuntimeError("osbuild failed: " + msg)

        return json.loads(r.stdout.decode("utf-8"))


class ImageInfo:
    def __init__(self, path: str):
        self.path = path
        self.verbosity = 1

    def run(self, target: str):
        cmd = [
            self.path,
            target
        ]

        if self.verbosity > 1:
            print("+" + " ".join(cmd), file=sys.stderr)

        r = subprocess.run(cmd,
                           check=False,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE)

        if r.returncode != 0:
            msg = r.stderr.decode("utf-8").strip()
            msg += r.stdout.decode("utf-8").strip()
            raise RuntimeError("image-info failed: " + msg)

        return json.loads(r.stdout.decode("utf-8"))


class TestCase:
    def __init__(self, path, data: dict) -> None:
        self.path = path
        self.id = data["id"]
        self.info = data["desc"]
        self.desc = data["manifest"]
        self.image_info = data.get("image-info")

        self.manifest: Optional[osbuild.Manifest] = None
        self.result: Optional[dict] = None
        self.error: Optional[str] = None

    def __str__(self):
        res = str(self.id)
        extra = []

        if not self.image_info:
            extra += ["no-image-info"]

        if extra:
            res += f" [{', '.join(extra)}]"

        return res

    @classmethod
    def load(cls, path: str) -> "TestCase":
        with open(path, "r", encoding='utf8') as f:
            data = json.load(f)

        return cls(path, data)

    def load_manifest(self, index: osbuild.meta.Index, verbose=False) -> bool:
        info = index.detect_format_info(self.desc)
        if not info:
            self.error = "Unsupported manifest format"
            return False

        fmt = info.module

        try:
            res = fmt.validate(self.desc, index)
            if not res:
                if verbose:
                    show_validation(res)
                self.error = "Invalid manifest: validation failed"
                return False

            self.manifest = fmt.load(self.desc, index)
        except Exception as e:  # pylint: disable=broad-except
            if verbose:
                print(traceback.format_exc())
            self.error = f"EXCEPTION: {e}"
            return False

        return True


class ImageTestSuite:
    pass


def load_tests(path) -> Iterator[TestCase]:
    files = os.scandir(path)

    for entry in files:
        if not entry.is_file():
            continue

        fullpath = os.path.join(path, entry.name)
        case = TestCase.load(fullpath)
        yield case


def detect_exports(test: TestCase) -> List[str]:

    pipelines = test.manifest.pipelines
    if not pipelines:
        return []

    # for now we just assume the last pipeline is the export
    return [next(reversed(pipelines))]


def detect_checkpoints(test: TestCase) -> List[str]:
    checkpoints = []
    manifest = test.manifest

    build = manifest.get("build")
    if build:
        checkpoints += [build.name]

    commit = manifest.get("ostree-commit")
    if commit:
        checkpoints += [commit.name]

    return checkpoints


def build_image(test: TestCase, osb: OSBuild) -> bool:
    exports = detect_exports(test)
    # construct the result path
    pipeline = test.manifest.pipelines[exports[0]]
    # assume if there's no filename in the last stage that image.raw will work
    filename = pipeline.stages[-1].options.get("filename", "image.raw")
    image_path = os.path.join(osb.outdir, exports[0], filename)

    checkpoints = detect_checkpoints(test)

    test.result = osb.run(manifest=test.desc, exports=exports, checkpoints=checkpoints)
    test.result["image"] = image_path
    if not os.path.exists(image_path):
        test.error = f"image {test.result['image']} not found"
        return False
    return True


def dump_image_info(test, folder):
    os.makedirs(folder, exist_ok=True)
    with open(os.path.join(folder, f"{test.id}.json"), "w", encoding="utf-8") as f:
        json.dump(test.result, f)


def compare_image_info(test: TestCase):
    if test.built_image_info != test.image_info:
        test.error = "image-info mismatch"


def make_filter(arch, distro, name):
    def fn(test):
        info = test.info

        if arch and info["arch"] != arch:
            return False

        if distro and info["distro"] != distro:
            return False

        if name:
            return fnmatch.fnmatch(test.id, name)

        return True

    return fn


def print_stats(tests: List[TestCase]) -> None:
    distors = defaultdict(int)
    archs = defaultdict(int)
    types = defaultdict(int)

    for test in tests:
        print(test)
        distors[test.info["distro"]] += 1
        archs[test.info["arch"]] += 1
        types[test.info["image-type"]] += 1

    print("Distributions:")
    for distro, count in sorted(distors.items()):
        print(f"\t{distro}: {count}")

    print("Architectures:")
    for arch, count in sorted(archs.items()):
        print(f"\t{arch}: {count}")

    print("Image types:")
    for image_type, count in sorted(types.items()):
        print(f"\t{image_type}: {count}")


def build_test(test, osb: OSBuild, imi: ImageInfo) -> bool:
    """
    Build the manifest in the test case and compile the image-info out of it.
    Upon error, store the reason in test.error and return False.
    """
    try:
        if not build_image(test, osb):
            return False
        test.built_image_info = imi.run(test.result["image"])
    except RuntimeError as e:
        test.error = str(e)
        return False
    return True


def clean_output(folder):
    """
    Empty the output folder as it can get quite big after a few runs.
    """
    for root, dirs, files in os.walk(folder):
        for f in files:
            os.unlink(os.path.join(root, f))
        for d in dirs:
            shutil.rmtree(os.path.join(root, d))


#pylint: disable=too-many-branches
def main():
    parser = argparse.ArgumentParser(description="osbuild image tests")
    parser.add_argument("--osbuild-path",
                        metavar="PATH",
                        type=os.path.abspath,
                        dest="osbuild",
                        default="/usr/bin/osbuild",
                        help="path to the osbuild executable"
                        )
    parser.add_argument(
        "--image-info-path",
        metavar="PATH",
        type=os.path.abspath,
        dest="image_info",
        default="tools/image-info",
        help="path to the image-info executable"
    )
    parser.add_argument(
        "--tempdir",
        metavar="DIRECTORY",
        type=os.path.abspath,
        default="/var/lib/osbuild-tests",
        help="directory where intermediary files will be stored")
    parser.add_argument(
        "--store",
        metavar="DIRECTORY",
        type=os.path.abspath,
        default="/var/lib/osbuild/store",
        help="directory where intermediary os trees are stored")
    parser.add_argument(
        "--output",
        metavar="DIRECTORY",
        type=os.path.abspath,
        default="/var/lib/osbuild/out",
        help="directory where result objects are stored")
    parser.add_argument(
        "--image-info-output",
        metavar="DIRECTORY",
        type=os.path.abspath,
        default="generated-image-infos/",
        help="directory where produced image info JSON will be stored")
    parser.add_argument(
        "--arch",
        metavar="ARCHITECTURE",
        type=str,
        default=platform.machine(),
        help="filter tests by architecture [default: host]")
    parser.add_argument(
        "--distro",
        metavar="DISTRIBUTION",
        type=str,
        help="filter tests by distribution")
    parser.add_argument(
        "--name",
        metavar="NAME",
        type=str,
        help="filter tests by name"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        default=False,
        help="Do not compile test cases"
    )
    parser.add_argument(
        "-l", "--libdir",
        metavar="DIRECTORY",
        type=os.path.abspath,
        default="/usr/lib/osbuild",
        help="directory containing the osbuild modules and library"
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        default=False,
        help="output more info"
    )
    parser.add_argument(
        "--generator-mode",
        action="store_true",
        default=False,
        help="Disengage comparison of the built images to their reference in the"
        " DB, turns the program into an image-info generator"
    )

    args = parser.parse_args()

    index = osbuild.meta.Index(args.libdir)

    print(f"Running in {os.path.realpath(os.curdir)}")

    tests = list(load_tests("manifest-db"))
    tests = list(filter(make_filter(args.arch, args.ditro, args.name), tests))

    if not tests:
        print(f" {RED}FAIL{RESET}: no tests to run")
        return 1

    for t in tests:
        print(f"{t.id}", end="", flush=True)

        res = t.load_manifest(index, verbose=args.verbose)
        if not res:
            print(f" {RED}FAIL{RESET}: {t.error}", end="")

        print("")

    print_stats(tests)

    osb = OSBuild(args.osbuild, args.store, args.output)
    imi = ImageInfo(args.image_info)

    success = True  # Set to False upon the first error
    for t in tests:
        print(f"{t.id}", end=" ", flush=True)
        if args.dry_run:
            print(f" Dry run: {GREEN}SUCCESS{RESET}")
            continue
        # Skip test cases that have failed validation of their manifest
        if t.error:
            print(f" {YELLOW}Warning (ignoring){RESET}: {t.error}")
            continue

        # If the generator_mode flag is set, the program behaves as an
        # image-info generator and skip the validation step. Which means that it
        # won't error out if the comparison fails. Also it will trigger the
        # build for every image regardless of the presence of an image-info in
        # the corresponding test case to validate against.
        if args.generator_mode:
            print("Building only:", end=" ", flush=True)
        else:
            print("Building & Comparing:", end=" ", flush=True)
            # If the program is configured to build & compare, then if the
            # test case haven't an image-info to compare to, it's useless to
            # build it. Because in this mode we are only interested in comparing
            # with what's in the DB.
            if not t.image_info:
                print(f" {YELLOW}Warning (ignoring){RESET}: No image info to compare to")
                continue

        if build_test(t, osb, imi):
            # Every generated image-info needs to be written to disk regardless
            # of the being in generated mode or not. So that if running the
            # program on a CI, one can download an image-info that failed
            # comparison.
            dump_image_info(t, args.image_info_output)
            if not args.generator_mode:
                compare_image_info(t)
        if t.error:
            print(f" {RED}FAIL{RESET}: {t.error}")
            success = False
        else:
            print(f" {GREEN}SUCCESS{RESET}")

        # in any case, clean the output folder to avoid filling out disk space
        clean_output(args.output)

    return 1 if not success else 0


if __name__ == "__main__":
    sys.exit(main())
